<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenVAS Manager: src/lsc_crypt.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_2e42f16cd70e299165562ff45749e93d.html">src</a>
  </div>
</div>
<div class="contents">
<h1>lsc_crypt.c</h1><a href="lsc__crypt_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* OpenVAS Manager</span>
<a name="l00002"></a>00002 <span class="comment"> * $Id$</span>
<a name="l00003"></a>00003 <span class="comment"> * Description: LSC credentials encryption support</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> * Authors:</span>
<a name="l00006"></a>00006 <span class="comment"> * Werner Koch &lt;wk@gnupg.org&gt;</span>
<a name="l00007"></a>00007 <span class="comment"> *</span>
<a name="l00008"></a>00008 <span class="comment"> * Copyright:</span>
<a name="l00009"></a>00009 <span class="comment"> * Copyright (C) 2013 Greenbone Networks GmbH</span>
<a name="l00010"></a>00010 <span class="comment"> *</span>
<a name="l00011"></a>00011 <span class="comment"> * This program is free software; you can redistribute it and/or</span>
<a name="l00012"></a>00012 <span class="comment"> * modify it under the terms of the GNU General Public License version</span>
<a name="l00013"></a>00013 <span class="comment"> * 2, or, at your option, any later version as published by the Free</span>
<a name="l00014"></a>00014 <span class="comment"> * Software Foundation</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * This program is distributed in the hope that it will be useful, but</span>
<a name="l00017"></a>00017 <span class="comment"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00018"></a>00018 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<a name="l00019"></a>00019 <span class="comment"> * General Public License for more details.</span>
<a name="l00020"></a>00020 <span class="comment"> *</span>
<a name="l00021"></a>00021 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
<a name="l00022"></a>00022 <span class="comment"> * along with this program; if not, write to the Free Software</span>
<a name="l00023"></a>00023 <span class="comment"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.</span>
<a name="l00024"></a>00024 <span class="comment"> */</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;glib.h&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;glib/gstdio.h&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;stdint.h&gt;</span>
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;openvas/base/gpgme_util.h&gt;</span>
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="preprocessor">#ifdef S_SPLINT_S</span>
<a name="l00036"></a>00036 <span class="preprocessor"></span><span class="preprocessor">#include &quot;<a class="code" href="splint_8h.html">splint.h</a>&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#endif</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;<a class="code" href="lsc__crypt_8h.html">lsc_crypt.h</a>&quot;</span>
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="preprocessor">#undef G_LOG_DOMAIN</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span>
<a name="l00045"></a><a class="code" href="lsc__crypt_8c.html#a1810a09af583816ca6b4ccf01ae848f7">00045</a> <span class="preprocessor">#define G_LOG_DOMAIN &quot;md  crypt&quot;</span>
<a name="l00046"></a>00046 <span class="preprocessor"></span>
<a name="l00054"></a><a class="code" href="lsc__crypt_8c.html#ad73469c152f2866238dcddf7a39718b0">00054</a> <span class="preprocessor">#define ENCRYPTION_KEY_UID &quot;OpenVAS Credential Encryption&quot;</span>
<a name="l00055"></a>00055 <span class="preprocessor"></span>
<a name="l00062"></a><a class="code" href="lsc__crypt_8c.html#a73728cb2adf706b78be4cd7ca7c27646">00062</a> <span class="preprocessor">#define MAX_VALUE_LENGTH  (128 * 1024)</span>
<a name="l00063"></a>00063 <span class="preprocessor"></span>
<a name="l00064"></a>00064 
<a name="l00065"></a>00065 <span class="comment">/* Provide a replacement for an error code in libgpg-error &gt; 1.10. */</span>
<a name="l00066"></a>00066 <span class="preprocessor">#ifndef GPG_ERR_AMBIGUOUS</span>
<a name="l00067"></a><a class="code" href="lsc__crypt_8c.html#a6947bff94e6b789a8f88c8c6f9cbb33c">00067</a> <span class="preprocessor"></span><span class="preprocessor"># define  GPG_ERR_AMBIGUOUS GPG_ERR_AMBIGUOUS_NAME</span>
<a name="l00068"></a>00068 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00069"></a>00069 <span class="preprocessor"></span>
<a name="l00073"></a><a class="code" href="structnamelist__s.html">00073</a> <span class="keyword">struct </span><a class="code" href="structnamelist__s.html" title="A linked list to help caching results.">namelist_s</a>
<a name="l00074"></a>00074 {
<a name="l00075"></a><a class="code" href="structnamelist__s.html#a1be5f6f2df8d3f70ded74bde5d94f5a1">00075</a>   <span class="keyword">struct </span><a class="code" href="structnamelist__s.html" title="A linked list to help caching results.">namelist_s</a> *<a class="code" href="structnamelist__s.html#a1be5f6f2df8d3f70ded74bde5d94f5a1">next</a>;
<a name="l00076"></a><a class="code" href="structnamelist__s.html#a5b4c973693b91f7e2077e47382addc30">00076</a>   <span class="keywordtype">size_t</span> <a class="code" href="structnamelist__s.html#a5b4c973693b91f7e2077e47382addc30">valoff</a>;      <span class="comment">/* Offset to the value in the plaintext buffer</span>
<a name="l00077"></a>00077 <span class="comment">                         or 0 if VALUE below is used instead.  Note</span>
<a name="l00078"></a>00078 <span class="comment">                         that a value will never be at the begin of</span>
<a name="l00079"></a>00079 <span class="comment">                         the plaintext buffer.  VALOFF and VALUE</span>
<a name="l00080"></a>00080 <span class="comment">                         0/NULL indicates a NULL value. */</span>
<a name="l00081"></a><a class="code" href="structnamelist__s.html#a2382546248b3fa55432d922fc5076f19">00081</a>   <span class="keywordtype">char</span> *<a class="code" href="structnamelist__s.html#a2382546248b3fa55432d922fc5076f19">value</a>;
<a name="l00082"></a><a class="code" href="structnamelist__s.html#a10e5f9a9cf791f9201d3a41250b36c3a">00082</a>   <span class="keywordtype">char</span> <a class="code" href="structnamelist__s.html#a10e5f9a9cf791f9201d3a41250b36c3a">name</a>[1];       <span class="comment">/* The name.  */</span>
<a name="l00083"></a>00083 };
<a name="l00084"></a>00084 
<a name="l00091"></a><a class="code" href="structlsc__crypt__ctx__s.html">00091</a> <span class="keyword">struct </span><a class="code" href="structlsc__crypt__ctx__s.html" title="The context object for encryption operations.">lsc_crypt_ctx_s</a>
<a name="l00092"></a>00092 {
<a name="l00093"></a><a class="code" href="structlsc__crypt__ctx__s.html#a6fa3a20ae883858a43ff96aae90fd2d6">00093</a>   gpgme_ctx_t <a class="code" href="structlsc__crypt__ctx__s.html#a6fa3a20ae883858a43ff96aae90fd2d6">encctx</a>;
<a name="l00094"></a><a class="code" href="structlsc__crypt__ctx__s.html#a9409691f9e38d04212edead1bf063f80">00094</a>   gpgme_key_t <a class="code" href="structlsc__crypt__ctx__s.html#a9409691f9e38d04212edead1bf063f80">enckey</a>;    <span class="comment">/* The key to be used for encryption.  */</span>
<a name="l00095"></a><a class="code" href="structlsc__crypt__ctx__s.html#abb5d2a695bfb86a8216151ef23d6fd07">00095</a>   <span class="keywordtype">char</span> *<a class="code" href="structlsc__crypt__ctx__s.html#abb5d2a695bfb86a8216151ef23d6fd07">plaintext</a>;
<a name="l00096"></a><a class="code" href="structlsc__crypt__ctx__s.html#a66371ebe2ece8c38da509965be46f2e3">00096</a>   <span class="keywordtype">size_t</span> <a class="code" href="structlsc__crypt__ctx__s.html#a66371ebe2ece8c38da509965be46f2e3">plaintextlen</a>;
<a name="l00097"></a><a class="code" href="structlsc__crypt__ctx__s.html#a29784e91a47ce697dde033756884b9e0">00097</a>   <span class="keyword">struct </span><a class="code" href="structnamelist__s.html" title="A linked list to help caching results.">namelist_s</a> *<a class="code" href="structlsc__crypt__ctx__s.html#a29784e91a47ce697dde033756884b9e0">namelist</a>; <span class="comment">/* Info describing PLAINTEXT.  */</span>
<a name="l00098"></a>00098 };
<a name="l00099"></a>00099 
<a name="l00100"></a>00100 
<a name="l00101"></a>00101 <span class="comment">/* Simple helper functions  */</span>
<a name="l00102"></a>00102 
<a name="l00111"></a>00111 <span class="keyword">static</span> G_GNUC_CONST <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l00112"></a>00112 nonnull (<span class="keyword">const</span> <span class="keywordtype">char</span> *s)
<a name="l00113"></a>00113 {
<a name="l00114"></a>00114   <span class="keywordflow">return</span> s? s :<span class="stringliteral">&quot;[none]&quot;</span>;
<a name="l00115"></a>00115 }
<a name="l00116"></a>00116 
<a name="l00117"></a>00117 
<a name="l00127"></a>00127 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00128"></a>00128 put32 (GString *buffer, uint32_t <a class="code" href="structnamelist__s.html#a2382546248b3fa55432d922fc5076f19">value</a>)
<a name="l00129"></a>00129 {
<a name="l00130"></a>00130   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> tmp[4];
<a name="l00131"></a>00131   tmp[0] = value &gt;&gt; 24;
<a name="l00132"></a>00132   tmp[1] = value &gt;&gt; 16;
<a name="l00133"></a>00133   tmp[2] = value &gt;&gt; 8;
<a name="l00134"></a>00134   tmp[3] = value;
<a name="l00135"></a>00135   g_string_append_len (buffer, (<span class="keywordtype">char</span>*)tmp, 4);
<a name="l00136"></a>00136 }
<a name="l00137"></a>00137 
<a name="l00138"></a>00138 
<a name="l00149"></a>00149 <span class="keyword">static</span> G_GNUC_PURE uint32_t
<a name="l00150"></a>00150 get32 (<span class="keyword">const</span> <span class="keywordtype">void</span> *buffer)
<a name="l00151"></a>00151 {
<a name="l00152"></a>00152   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *s = buffer;
<a name="l00153"></a>00153   uint32_t value;
<a name="l00154"></a>00154 
<a name="l00155"></a>00155   value  = s[0] &lt;&lt; 24;
<a name="l00156"></a>00156   value |= s[1] &lt;&lt; 16;
<a name="l00157"></a>00157   value |= s[2] &lt;&lt; 8;
<a name="l00158"></a>00158   value |= s[3];
<a name="l00159"></a>00159 
<a name="l00160"></a>00160   <span class="keywordflow">return</span> value;
<a name="l00161"></a>00161 }
<a name="l00162"></a>00162 
<a name="l00175"></a>00175 <span class="keyword">static</span> <span class="keywordtype">void</span>
<a name="l00176"></a>00176 log_gpgme (GLogLevelFlags level, gpg_error_t err, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ...)
<a name="l00177"></a>00177 {
<a name="l00178"></a>00178   va_list arg_ptr;
<a name="l00179"></a>00179   <span class="keywordtype">char</span> *msg;
<a name="l00180"></a>00180 
<a name="l00181"></a>00181   va_start (arg_ptr, fmt);
<a name="l00182"></a>00182   msg = g_strdup_vprintf (fmt, arg_ptr);
<a name="l00183"></a>00183   va_end (arg_ptr);
<a name="l00184"></a>00184   <span class="keywordflow">if</span> (err &amp;&amp; gpg_err_source (err) != GPG_ERR_SOURCE_ANY)
<a name="l00185"></a>00185     g_log (<a class="code" href="lsc__crypt_8c.html#a1810a09af583816ca6b4ccf01ae848f7" title="GLib log domain.">G_LOG_DOMAIN</a>, level, <span class="stringliteral">&quot;%s: %s &lt;%s&gt;&quot;</span>,
<a name="l00186"></a>00186            msg, gpg_strerror (err), gpg_strsource (err));
<a name="l00187"></a>00187   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (err)
<a name="l00188"></a>00188     g_log (<a class="code" href="lsc__crypt_8c.html#a1810a09af583816ca6b4ccf01ae848f7" title="GLib log domain.">G_LOG_DOMAIN</a>, level, <span class="stringliteral">&quot;%s: %s&quot;</span>,
<a name="l00189"></a>00189            msg, gpg_strerror (err));
<a name="l00190"></a>00190   <span class="keywordflow">else</span>
<a name="l00191"></a>00191     g_log (<a class="code" href="lsc__crypt_8c.html#a1810a09af583816ca6b4ccf01ae848f7" title="GLib log domain.">G_LOG_DOMAIN</a>, level, <span class="stringliteral">&quot;%s&quot;</span>,
<a name="l00192"></a>00192            msg);
<a name="l00193"></a>00193   g_free (msg);
<a name="l00194"></a>00194 }
<a name="l00195"></a>00195 
<a name="l00196"></a>00196 
<a name="l00197"></a>00197 
<a name="l00198"></a>00198 
<a name="l00199"></a>00199 <span class="comment">/* Local functions. */</span>
<a name="l00200"></a>00200 
<a name="l00201"></a>00201 
<a name="l00211"></a>00211 <span class="keyword">static</span> <span class="keywordtype">int</span>
<a name="l00212"></a>00212 create_the_key (<a class="code" href="structlsc__crypt__ctx__s.html" title="The context object for encryption operations.">lsc_crypt_ctx_t</a> ctx)
<a name="l00213"></a>00213 {
<a name="l00214"></a>00214   <span class="keyword">const</span> <span class="keywordtype">char</span> parms[] =
<a name="l00215"></a>00215     <span class="stringliteral">&quot;&lt;GnupgKeyParms format=\&quot;internal\&quot;&gt;\n&quot;</span>
<a name="l00216"></a>00216     <span class="stringliteral">&quot;Key-Type: RSA\n&quot;</span>
<a name="l00217"></a>00217     <span class="stringliteral">&quot;Key-Length: 2048\n&quot;</span>
<a name="l00218"></a>00218     <span class="stringliteral">&quot;Key-Usage: encrypt\n&quot;</span>
<a name="l00219"></a>00219     <span class="stringliteral">&quot;Name-Real: &quot;</span> <a class="code" href="lsc__crypt_8c.html#ad73469c152f2866238dcddf7a39718b0" title="The name of the encryption key.">ENCRYPTION_KEY_UID</a> <span class="stringliteral">&quot;\n&quot;</span>
<a name="l00220"></a>00220     <span class="stringliteral">&quot;Expire-Date: 0\n&quot;</span>
<a name="l00221"></a>00221     <span class="stringliteral">&quot;%no-protection\n&quot;</span>
<a name="l00222"></a>00222     <span class="stringliteral">&quot;%no-ask-passphrase\n&quot;</span>
<a name="l00223"></a>00223     <span class="stringliteral">&quot;&lt;/GnupgKeyParms&gt;\n&quot;</span>;
<a name="l00224"></a>00224   gpg_error_t err;
<a name="l00225"></a>00225 
<a name="l00226"></a>00226   log_gpgme (G_LOG_LEVEL_INFO, 0, <span class="stringliteral">&quot;starting key generation ...&quot;</span>);
<a name="l00227"></a>00227   err = gpgme_op_genkey (ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a6fa3a20ae883858a43ff96aae90fd2d6">encctx</a>, parms, NULL, NULL);
<a name="l00228"></a>00228   <span class="keywordflow">if</span> (err)
<a name="l00229"></a>00229     {
<a name="l00230"></a>00230       log_gpgme(G_LOG_LEVEL_WARNING, err, <span class="stringliteral">&quot;error creating OpenPGP key &apos;%s&apos;&quot;</span>,
<a name="l00231"></a>00231                 <a class="code" href="lsc__crypt_8c.html#ad73469c152f2866238dcddf7a39718b0" title="The name of the encryption key.">ENCRYPTION_KEY_UID</a>);
<a name="l00232"></a>00232       <span class="keywordflow">return</span> -1;
<a name="l00233"></a>00233     }
<a name="l00234"></a>00234   log_gpgme (G_LOG_LEVEL_INFO, 0,
<a name="l00235"></a>00235              <span class="stringliteral">&quot;OpenPGP key &apos;%s&apos; has been generated&quot;</span>, <a class="code" href="lsc__crypt_8c.html#ad73469c152f2866238dcddf7a39718b0" title="The name of the encryption key.">ENCRYPTION_KEY_UID</a>);
<a name="l00236"></a>00236   <span class="keywordflow">return</span> 0;
<a name="l00237"></a>00237 }
<a name="l00238"></a>00238 
<a name="l00239"></a>00239 
<a name="l00251"></a>00251 <span class="keyword">static</span> gpgme_key_t
<a name="l00252"></a>00252 find_the_key (<a class="code" href="structlsc__crypt__ctx__s.html" title="The context object for encryption operations.">lsc_crypt_ctx_t</a> ctx, gboolean no_create)
<a name="l00253"></a>00253 {
<a name="l00254"></a>00254   gpg_error_t err;
<a name="l00255"></a>00255   <span class="keywordtype">int</span> nfound, any_skipped;
<a name="l00256"></a>00256   gpgme_key_t found, key;
<a name="l00257"></a>00257 
<a name="l00258"></a>00258  again:
<a name="l00259"></a>00259   <span class="comment">/* Search for the public key.  Note that the &quot;=&quot; prefix flag enables</span>
<a name="l00260"></a>00260 <span class="comment">     an exact search.  */</span>
<a name="l00261"></a>00261   err = gpgme_op_keylist_start (ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a6fa3a20ae883858a43ff96aae90fd2d6">encctx</a>, <span class="stringliteral">&quot;=&quot;</span><a class="code" href="lsc__crypt_8c.html#ad73469c152f2866238dcddf7a39718b0" title="The name of the encryption key.">ENCRYPTION_KEY_UID</a>, 0);
<a name="l00262"></a>00262   <span class="keywordflow">if</span> (err)
<a name="l00263"></a>00263     {
<a name="l00264"></a>00264       log_gpgme (G_LOG_LEVEL_WARNING, err,
<a name="l00265"></a>00265                  <span class="stringliteral">&quot;error starting search for OpenPGP key &apos;%s&apos;&quot;</span>,
<a name="l00266"></a>00266                  <a class="code" href="lsc__crypt_8c.html#ad73469c152f2866238dcddf7a39718b0" title="The name of the encryption key.">ENCRYPTION_KEY_UID</a>);
<a name="l00267"></a>00267       <span class="keywordflow">return</span> NULL;
<a name="l00268"></a>00268     }
<a name="l00269"></a>00269 
<a name="l00270"></a>00270   nfound = any_skipped = 0;
<a name="l00271"></a>00271   found = NULL;
<a name="l00272"></a>00272   <span class="keywordflow">while</span> (!(err = gpgme_op_keylist_next (ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a6fa3a20ae883858a43ff96aae90fd2d6">encctx</a>, &amp;key)))
<a name="l00273"></a>00273     {
<a name="l00274"></a>00274       <span class="keywordflow">if</span> (!key-&gt;can_encrypt || key-&gt;revoked || key-&gt;expired
<a name="l00275"></a>00275           || key-&gt;disabled || key-&gt;invalid)
<a name="l00276"></a>00276         {
<a name="l00277"></a>00277           log_gpgme (G_LOG_LEVEL_MESSAGE, 0, <span class="stringliteral">&quot;skipping unusable OpenPGP key %s&quot;</span>,
<a name="l00278"></a>00278                      key-&gt;subkeys? nonnull (key-&gt;subkeys-&gt;keyid):<span class="stringliteral">&quot;?&quot;</span>);
<a name="l00279"></a>00279           any_skipped = 1;
<a name="l00280"></a>00280           <span class="keywordflow">continue</span>;
<a name="l00281"></a>00281         }
<a name="l00282"></a>00282       nfound++;
<a name="l00283"></a>00283       <span class="keywordflow">if</span> (!found)
<a name="l00284"></a>00284         {
<a name="l00285"></a>00285           gpgme_key_ref (key);
<a name="l00286"></a>00286           found = key;
<a name="l00287"></a>00287         }
<a name="l00288"></a>00288       gpgme_key_unref (key);
<a name="l00289"></a>00289     }
<a name="l00290"></a>00290   <span class="keywordflow">if</span> (gpgme_err_code (err) == GPG_ERR_EOF)
<a name="l00291"></a>00291     err = 0;
<a name="l00292"></a>00292   gpgme_op_keylist_end (ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a6fa3a20ae883858a43ff96aae90fd2d6">encctx</a>);
<a name="l00293"></a>00293 
<a name="l00294"></a>00294   <span class="keywordflow">if</span> (err)
<a name="l00295"></a>00295     {
<a name="l00296"></a>00296       <span class="comment">/* We better reset the gpgme context after an error.  */</span>
<a name="l00297"></a>00297       gpgme_release (ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a6fa3a20ae883858a43ff96aae90fd2d6">encctx</a>);
<a name="l00298"></a>00298       ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a6fa3a20ae883858a43ff96aae90fd2d6">encctx</a> = openvas_init_gpgme_ctx ();
<a name="l00299"></a>00299       <span class="keywordflow">if</span> (!ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a6fa3a20ae883858a43ff96aae90fd2d6">encctx</a>)
<a name="l00300"></a>00300         {
<a name="l00301"></a>00301           g_critical (<span class="stringliteral">&quot;%s: can&apos;t continue w/o a gpgme context\n&quot;</span>, G_STRFUNC);
<a name="l00302"></a>00302           exit (EXIT_FAILURE);
<a name="l00303"></a>00303         }
<a name="l00304"></a>00304     }
<a name="l00305"></a>00305   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!found)
<a name="l00306"></a>00306     {
<a name="l00307"></a>00307       <span class="keyword">static</span> <span class="keywordtype">int</span> genkey_tried;
<a name="l00308"></a>00308 
<a name="l00309"></a>00309       <span class="comment">/* Try to create the key if we have not seen any matching key at</span>
<a name="l00310"></a>00310 <span class="comment">         all and if this is the first time in this process&apos; lifetime.  */</span>
<a name="l00311"></a>00311       <span class="keywordflow">if</span> (!any_skipped &amp;&amp; !genkey_tried &amp;&amp; !no_create)
<a name="l00312"></a>00312         {
<a name="l00313"></a>00313           genkey_tried = 1;
<a name="l00314"></a>00314           <span class="keywordflow">if</span> (!create_the_key (ctx))
<a name="l00315"></a>00315             <span class="keywordflow">goto</span> again; <span class="comment">/* Created - search again.  */</span>
<a name="l00316"></a>00316         }
<a name="l00317"></a>00317 
<a name="l00318"></a>00318       err = gpg_err_make (GPG_ERR_SOURCE_ANY, GPG_ERR_NOT_FOUND);
<a name="l00319"></a>00319     }
<a name="l00320"></a>00320   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nfound &gt; 1)
<a name="l00321"></a>00321     err = gpg_err_make (GPG_ERR_SOURCE_ANY, <a class="code" href="lsc__crypt_8c.html#a6947bff94e6b789a8f88c8c6f9cbb33c">GPG_ERR_AMBIGUOUS</a>);
<a name="l00322"></a>00322 
<a name="l00323"></a>00323   <span class="keywordflow">if</span> (err)
<a name="l00324"></a>00324     {
<a name="l00325"></a>00325       log_gpgme (G_LOG_LEVEL_MESSAGE, err,
<a name="l00326"></a>00326                  <span class="stringliteral">&quot;error searching for OpenPGP key &apos;%s&apos;&quot;</span>,
<a name="l00327"></a>00327                  <a class="code" href="lsc__crypt_8c.html#ad73469c152f2866238dcddf7a39718b0" title="The name of the encryption key.">ENCRYPTION_KEY_UID</a>);
<a name="l00328"></a>00328       gpgme_key_unref (found);
<a name="l00329"></a>00329       found = NULL;
<a name="l00330"></a>00330     }
<a name="l00331"></a>00331 
<a name="l00332"></a>00332   <span class="keywordflow">return</span> found;
<a name="l00333"></a>00333 }
<a name="l00334"></a>00334 
<a name="l00335"></a>00335 
<a name="l00349"></a>00349 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l00350"></a>00350 do_encrypt (<a class="code" href="structlsc__crypt__ctx__s.html" title="The context object for encryption operations.">lsc_crypt_ctx_t</a> ctx, <span class="keyword">const</span> <span class="keywordtype">void</span> *plaintext, <span class="keywordtype">size_t</span> plaintextlen)
<a name="l00351"></a>00351 {
<a name="l00352"></a>00352   gpg_error_t err;
<a name="l00353"></a>00353   gpgme_data_t in, out;
<a name="l00354"></a>00354   gpgme_key_t keyarray[2];
<a name="l00355"></a>00355   <span class="keywordtype">char</span> *ciphertext;
<a name="l00356"></a>00356   <span class="keywordtype">size_t</span> ciphertextlen;
<a name="l00357"></a>00357   <span class="keywordtype">char</span> *result;
<a name="l00358"></a>00358 
<a name="l00359"></a>00359   <span class="keywordflow">if</span> (!ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a9409691f9e38d04212edead1bf063f80">enckey</a>)
<a name="l00360"></a>00360     {
<a name="l00361"></a>00361       ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a9409691f9e38d04212edead1bf063f80">enckey</a> = find_the_key (ctx, 0);
<a name="l00362"></a>00362       <span class="keywordflow">if</span> (!ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a9409691f9e38d04212edead1bf063f80">enckey</a>)
<a name="l00363"></a>00363         <span class="keywordflow">return</span> NULL;
<a name="l00364"></a>00364     }
<a name="l00365"></a>00365 
<a name="l00366"></a>00366   err = gpgme_data_new_from_mem (&amp;in, plaintext, plaintextlen, 0);
<a name="l00367"></a>00367   <span class="keywordflow">if</span> (err)
<a name="l00368"></a>00368     {
<a name="l00369"></a>00369       log_gpgme (G_LOG_LEVEL_WARNING, err,
<a name="l00370"></a>00370                  <span class="stringliteral">&quot;%s: error creating data object from plaintext&quot;</span>,
<a name="l00371"></a>00371                  G_STRFUNC);
<a name="l00372"></a>00372       <span class="keywordflow">return</span> NULL;
<a name="l00373"></a>00373     }
<a name="l00374"></a>00374 
<a name="l00375"></a>00375   err = gpgme_data_new (&amp;out);
<a name="l00376"></a>00376   <span class="keywordflow">if</span> (err)
<a name="l00377"></a>00377     {
<a name="l00378"></a>00378       log_gpgme (G_LOG_LEVEL_WARNING, err,
<a name="l00379"></a>00379                  <span class="stringliteral">&quot;%s: error creating data object for ciphertext&quot;</span>,
<a name="l00380"></a>00380                  G_STRFUNC);
<a name="l00381"></a>00381       gpgme_data_release (in);
<a name="l00382"></a>00382       <span class="keywordflow">return</span> NULL;
<a name="l00383"></a>00383     }
<a name="l00384"></a>00384 
<a name="l00385"></a>00385   gpgme_set_armor (ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a6fa3a20ae883858a43ff96aae90fd2d6">encctx</a>, 0);
<a name="l00386"></a>00386   keyarray[0] = ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a9409691f9e38d04212edead1bf063f80">enckey</a>;
<a name="l00387"></a>00387   keyarray[1] = NULL;
<a name="l00388"></a>00388   err = gpgme_op_encrypt (ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a6fa3a20ae883858a43ff96aae90fd2d6">encctx</a>, keyarray,
<a name="l00389"></a>00389                           GPGME_ENCRYPT_ALWAYS_TRUST, in, out);
<a name="l00390"></a>00390   gpgme_data_release (in);
<a name="l00391"></a>00391   <span class="keywordflow">if</span> (err)
<a name="l00392"></a>00392     {
<a name="l00393"></a>00393       log_gpgme (G_LOG_LEVEL_WARNING, err,
<a name="l00394"></a>00394                  <span class="stringliteral">&quot;%s: error encrypting credential&quot;</span>,
<a name="l00395"></a>00395                  G_STRFUNC);
<a name="l00396"></a>00396       gpgme_data_release (out);
<a name="l00397"></a>00397       <span class="keywordflow">return</span> NULL;
<a name="l00398"></a>00398     }
<a name="l00399"></a>00399   ciphertext = gpgme_data_release_and_get_mem (out, &amp;ciphertextlen);
<a name="l00400"></a>00400   <span class="keywordflow">if</span> (!ciphertext)
<a name="l00401"></a>00401     {
<a name="l00402"></a>00402       g_critical (<span class="stringliteral">&quot;%s: error snatching memory&quot;</span>, G_STRFUNC);
<a name="l00403"></a>00403       exit (EXIT_FAILURE);
<a name="l00404"></a>00404     }
<a name="l00405"></a>00405 
<a name="l00406"></a>00406   result = g_base64_encode ((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *)ciphertext, ciphertextlen);
<a name="l00407"></a>00407   gpgme_free (ciphertext);
<a name="l00408"></a>00408 
<a name="l00409"></a>00409   <span class="keywordflow">return</span> result;
<a name="l00410"></a>00410 }
<a name="l00411"></a>00411 
<a name="l00412"></a>00412 
<a name="l00431"></a>00431 <span class="keyword">static</span> <span class="keywordtype">char</span> *
<a name="l00432"></a>00432 do_decrypt (<a class="code" href="structlsc__crypt__ctx__s.html" title="The context object for encryption operations.">lsc_crypt_ctx_t</a> ctx, <span class="keyword">const</span> <span class="keywordtype">char</span> *cipherstring,
<a name="l00433"></a>00433             <span class="keywordtype">size_t</span> *r_plaintextlen)
<a name="l00434"></a>00434 {
<a name="l00435"></a>00435   gpg_error_t err;
<a name="l00436"></a>00436   gpgme_data_t in, out;
<a name="l00437"></a>00437   <span class="keywordtype">char</span> *ciphertext;
<a name="l00438"></a>00438   <span class="keywordtype">size_t</span> ciphertextlen;
<a name="l00439"></a>00439   <span class="keywordtype">char</span> *result;
<a name="l00440"></a>00440 
<a name="l00441"></a>00441   <span class="comment">/* Unfortunately GPGME does not yet support plain base64 encoding.  */</span>
<a name="l00442"></a>00442   ciphertext = (<span class="keywordtype">char</span> *)g_base64_decode (cipherstring, &amp;ciphertextlen);
<a name="l00443"></a>00443   <span class="keywordflow">if</span> (!ciphertext || !ciphertextlen)
<a name="l00444"></a>00444     <span class="keywordflow">return</span> NULL;  <span class="comment">/* Empty or bad encoding.  */</span>
<a name="l00445"></a>00445 
<a name="l00446"></a>00446   err = gpgme_data_new_from_mem (&amp;in, ciphertext, ciphertextlen, 0);
<a name="l00447"></a>00447   <span class="keywordflow">if</span> (err)
<a name="l00448"></a>00448     {
<a name="l00449"></a>00449       log_gpgme (G_LOG_LEVEL_WARNING, err,
<a name="l00450"></a>00450                  <span class="stringliteral">&quot;%s: error creating data object from ciphertext&quot;</span>,
<a name="l00451"></a>00451                  G_STRFUNC);
<a name="l00452"></a>00452       g_free (ciphertext);
<a name="l00453"></a>00453       <span class="keywordflow">return</span> NULL;
<a name="l00454"></a>00454     }
<a name="l00455"></a>00455   <span class="comment">/* (We must release CIPHERTEXT only after IN.) */</span>
<a name="l00456"></a>00456 
<a name="l00457"></a>00457   err = gpgme_data_new (&amp;out);
<a name="l00458"></a>00458   <span class="keywordflow">if</span> (err)
<a name="l00459"></a>00459     {
<a name="l00460"></a>00460       log_gpgme (G_LOG_LEVEL_WARNING, err,
<a name="l00461"></a>00461                  <span class="stringliteral">&quot;%s: error creating data object for plaintext&quot;</span>,
<a name="l00462"></a>00462                  G_STRFUNC);
<a name="l00463"></a>00463       gpgme_data_release (in);
<a name="l00464"></a>00464       g_free (ciphertext);
<a name="l00465"></a>00465       <span class="keywordflow">return</span> NULL;
<a name="l00466"></a>00466     }
<a name="l00467"></a>00467 
<a name="l00468"></a>00468   err = gpgme_op_decrypt (ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a6fa3a20ae883858a43ff96aae90fd2d6">encctx</a>, in, out);
<a name="l00469"></a>00469   gpgme_data_release (in);
<a name="l00470"></a>00470   g_free (ciphertext);
<a name="l00471"></a>00471   <span class="keywordflow">if</span> (err)
<a name="l00472"></a>00472     {
<a name="l00473"></a>00473       gpgme_decrypt_result_t decres;
<a name="l00474"></a>00474       gpgme_recipient_t recp;
<a name="l00475"></a>00475 
<a name="l00476"></a>00476       gpgme_data_release (out);
<a name="l00477"></a>00477       log_gpgme (G_LOG_LEVEL_WARNING, err, <span class="stringliteral">&quot;error decrypting credential&quot;</span>);
<a name="l00478"></a>00478       decres = gpgme_op_decrypt_result (ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a6fa3a20ae883858a43ff96aae90fd2d6">encctx</a>);
<a name="l00479"></a>00479       <span class="keywordflow">if</span> (decres-&gt;unsupported_algorithm)
<a name="l00480"></a>00480         log_gpgme (G_LOG_LEVEL_INFO, 0, <span class="stringliteral">&quot;   unsupported algorithm (%s)&quot;</span>,
<a name="l00481"></a>00481                    decres-&gt;unsupported_algorithm);
<a name="l00482"></a>00482       <span class="keywordflow">if</span> (decres-&gt;wrong_key_usage)
<a name="l00483"></a>00483         log_gpgme (G_LOG_LEVEL_INFO, 0, <span class="stringliteral">&quot;   wrong key usage&quot;</span>);
<a name="l00484"></a>00484       <span class="keywordflow">for</span> (recp = decres-&gt;recipients; recp; recp = recp-&gt;next)
<a name="l00485"></a>00485         log_gpgme (G_LOG_LEVEL_INFO, recp-&gt;status,
<a name="l00486"></a>00486                    <span class="stringliteral">&quot;   encrypted to keyid %s, algo=%d&quot;</span>,
<a name="l00487"></a>00487                    recp-&gt;keyid, recp-&gt;pubkey_algo);
<a name="l00488"></a>00488       <span class="keywordflow">return</span> NULL;
<a name="l00489"></a>00489     }
<a name="l00490"></a>00490   result = gpgme_data_release_and_get_mem (out, r_plaintextlen);
<a name="l00491"></a>00491   <span class="keywordflow">if</span> (!result)
<a name="l00492"></a>00492     {
<a name="l00493"></a>00493       g_critical (<span class="stringliteral">&quot;%s: error snatching memory&quot;</span>, G_STRFUNC);
<a name="l00494"></a>00494       exit (EXIT_FAILURE);
<a name="l00495"></a>00495     }
<a name="l00496"></a>00496 
<a name="l00497"></a>00497   <span class="keywordflow">return</span> result;
<a name="l00498"></a>00498 }
<a name="l00499"></a>00499 
<a name="l00500"></a>00500 
<a name="l00501"></a>00501 
<a name="l00502"></a>00502 <span class="comment">/* API */</span>
<a name="l00503"></a>00503 
<a name="l00510"></a>00510 <a class="code" href="structlsc__crypt__ctx__s.html" title="The context object for encryption operations.">lsc_crypt_ctx_t</a>
<a name="l00511"></a><a class="code" href="lsc__crypt_8h.html#a0d1618fba491ec2d5707545793944d18">00511</a> <a class="code" href="lsc__crypt_8c.html#a0d1618fba491ec2d5707545793944d18" title="Return a new context for LSC encryption.">lsc_crypt_new</a> ()
<a name="l00512"></a>00512 {
<a name="l00513"></a>00513   <a class="code" href="structlsc__crypt__ctx__s.html" title="The context object for encryption operations.">lsc_crypt_ctx_t</a> ctx;
<a name="l00514"></a>00514 
<a name="l00515"></a>00515   ctx = g_malloc0 (<span class="keyword">sizeof</span> *ctx);
<a name="l00516"></a>00516   ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a6fa3a20ae883858a43ff96aae90fd2d6">encctx</a> = openvas_init_gpgme_ctx ();
<a name="l00517"></a>00517   <span class="keywordflow">if</span> (!ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a6fa3a20ae883858a43ff96aae90fd2d6">encctx</a>)
<a name="l00518"></a>00518     {
<a name="l00519"></a>00519       g_critical (<span class="stringliteral">&quot;%s: can&apos;t continue w/o a gpgme context\n&quot;</span>, G_STRFUNC);
<a name="l00520"></a>00520       exit (EXIT_FAILURE);
<a name="l00521"></a>00521     }
<a name="l00522"></a>00522 
<a name="l00523"></a>00523   <span class="keywordflow">return</span> ctx;
<a name="l00524"></a>00524 }
<a name="l00525"></a>00525 
<a name="l00531"></a>00531 <span class="keywordtype">void</span>
<a name="l00532"></a><a class="code" href="lsc__crypt_8h.html#aa383411c640ff7e7bfcac95ea1fba084">00532</a> <a class="code" href="lsc__crypt_8c.html#ae74d739b0aa90471b2ee7da8d415d548" title="Release an LSC encryption context.">lsc_crypt_release</a> (<a class="code" href="structlsc__crypt__ctx__s.html" title="The context object for encryption operations.">lsc_crypt_ctx_t</a> ctx)
<a name="l00533"></a>00533 {
<a name="l00534"></a>00534   <span class="keywordflow">if</span> (!ctx)
<a name="l00535"></a>00535     <span class="keywordflow">return</span>;
<a name="l00536"></a>00536   <a class="code" href="lsc__crypt_8c.html#a87f56fad71eec65ff82baf9df5084baf" title="Flush an LSC encryption context.">lsc_crypt_flush</a> (ctx);
<a name="l00537"></a>00537   <span class="keywordflow">if</span> (ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a6fa3a20ae883858a43ff96aae90fd2d6">encctx</a>) <span class="comment">/* Check required for gpgme &lt; 1.3.1 */</span>
<a name="l00538"></a>00538     gpgme_release (ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a6fa3a20ae883858a43ff96aae90fd2d6">encctx</a>);
<a name="l00539"></a>00539   g_free (ctx);
<a name="l00540"></a>00540 }
<a name="l00541"></a>00541 
<a name="l00552"></a>00552 <span class="keywordtype">int</span>
<a name="l00553"></a><a class="code" href="lsc__crypt_8h.html#a20aec9824d6c37f9c133d06347750f69">00553</a> <a class="code" href="lsc__crypt_8c.html#a20aec9824d6c37f9c133d06347750f69" title="Create the standard credential encryption key.">lsc_crypt_create_key</a> ()
<a name="l00554"></a>00554 {
<a name="l00555"></a>00555   <span class="keywordtype">int</span> res = -1;
<a name="l00556"></a>00556   <a class="code" href="structlsc__crypt__ctx__s.html" title="The context object for encryption operations.">lsc_crypt_ctx_t</a> ctx;
<a name="l00557"></a>00557   gpgme_key_t key;
<a name="l00558"></a>00558 
<a name="l00559"></a>00559   ctx = <a class="code" href="lsc__crypt_8c.html#a0d1618fba491ec2d5707545793944d18" title="Return a new context for LSC encryption.">lsc_crypt_new</a> ();
<a name="l00560"></a>00560   key = find_the_key (ctx, TRUE);
<a name="l00561"></a>00561   <span class="keywordflow">if</span> (key)
<a name="l00562"></a>00562     {
<a name="l00563"></a>00563       gpgme_key_unref (key);
<a name="l00564"></a>00564       g_warning (<span class="stringliteral">&quot;A credentials encryption key already exists - &quot;</span>
<a name="l00565"></a>00565                  <span class="stringliteral">&quot;not creating another one.&quot;</span>);
<a name="l00566"></a>00566       res = 1;
<a name="l00567"></a>00567     }
<a name="l00568"></a>00568   <span class="keywordflow">else</span>
<a name="l00569"></a>00569     {
<a name="l00570"></a>00570       <span class="keywordflow">if</span> (!create_the_key (ctx))
<a name="l00571"></a>00571         res = 0;
<a name="l00572"></a>00572     }
<a name="l00573"></a>00573 
<a name="l00574"></a>00574   <a class="code" href="lsc__crypt_8c.html#ae74d739b0aa90471b2ee7da8d415d548" title="Release an LSC encryption context.">lsc_crypt_release</a> (ctx);
<a name="l00575"></a>00575   <span class="keywordflow">return</span> res;
<a name="l00576"></a>00576 }
<a name="l00577"></a>00577 
<a name="l00578"></a>00578 
<a name="l00589"></a>00589 <span class="keywordtype">void</span>
<a name="l00590"></a><a class="code" href="lsc__crypt_8h.html#a1266a9fd2014242038fe742ed08d3dc0">00590</a> <a class="code" href="lsc__crypt_8c.html#a87f56fad71eec65ff82baf9df5084baf" title="Flush an LSC encryption context.">lsc_crypt_flush</a> (<a class="code" href="structlsc__crypt__ctx__s.html" title="The context object for encryption operations.">lsc_crypt_ctx_t</a> ctx)
<a name="l00591"></a>00591 {
<a name="l00592"></a>00592   <span class="keywordflow">if</span> (!ctx)
<a name="l00593"></a>00593     <span class="keywordflow">return</span>;
<a name="l00594"></a>00594   <span class="keywordflow">while</span> (ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a29784e91a47ce697dde033756884b9e0">namelist</a>)
<a name="l00595"></a>00595     {
<a name="l00596"></a>00596       <span class="keyword">struct </span><a class="code" href="structnamelist__s.html" title="A linked list to help caching results.">namelist_s</a> *nl = ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a29784e91a47ce697dde033756884b9e0">namelist</a>-&gt;<a class="code" href="structnamelist__s.html#a1be5f6f2df8d3f70ded74bde5d94f5a1">next</a>;
<a name="l00597"></a>00597       g_free (ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a29784e91a47ce697dde033756884b9e0">namelist</a>-&gt;<a class="code" href="structnamelist__s.html#a2382546248b3fa55432d922fc5076f19">value</a>);
<a name="l00598"></a>00598       g_free (ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a29784e91a47ce697dde033756884b9e0">namelist</a>);
<a name="l00599"></a>00599       ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a29784e91a47ce697dde033756884b9e0">namelist</a> = nl;
<a name="l00600"></a>00600     }
<a name="l00601"></a>00601   g_free (ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#abb5d2a695bfb86a8216151ef23d6fd07">plaintext</a>);
<a name="l00602"></a>00602   ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#abb5d2a695bfb86a8216151ef23d6fd07">plaintext</a> = NULL;
<a name="l00603"></a>00603 }
<a name="l00604"></a>00604 
<a name="l00605"></a>00605 
<a name="l00619"></a>00619 <span class="keywordtype">char</span> *
<a name="l00620"></a><a class="code" href="lsc__crypt_8h.html#a80d28b4404b5cb8edd2588398b142e91">00620</a> <a class="code" href="lsc__crypt_8c.html#af09d8d15f2a154ba36149f10a8149101" title="Encrypt a list of name/value pairs.">lsc_crypt_encrypt</a> (<a class="code" href="structlsc__crypt__ctx__s.html" title="The context object for encryption operations.">lsc_crypt_ctx_t</a> ctx, <span class="keyword">const</span> <span class="keywordtype">char</span> *first_name, ...)
<a name="l00621"></a>00621 {
<a name="l00622"></a>00622   va_list arg_ptr;
<a name="l00623"></a>00623   GString *stringbuf;
<a name="l00624"></a>00624   <span class="keywordtype">char</span> *plaintext;
<a name="l00625"></a>00625   <span class="keywordtype">size_t</span> plaintextlen;
<a name="l00626"></a>00626   <span class="keywordtype">char</span> *ciphertext;
<a name="l00627"></a>00627   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structnamelist__s.html#a10e5f9a9cf791f9201d3a41250b36c3a">name</a>, *value;
<a name="l00628"></a>00628   <span class="keywordtype">size_t</span> len;
<a name="l00629"></a>00629 
<a name="l00630"></a>00630   <span class="keywordflow">if</span> (!ctx || !first_name)
<a name="l00631"></a>00631     <span class="keywordflow">return</span> NULL;
<a name="l00632"></a>00632 
<a name="l00633"></a>00633   <span class="comment">/* Assuming a 2048 bit RSA ssh private key in PEM encoding, a buffer</span>
<a name="l00634"></a>00634 <span class="comment">     with an initial size of 2k should be large enough.  */</span>
<a name="l00635"></a>00635   stringbuf = g_string_sized_new (2048);
<a name="l00636"></a>00636 
<a name="l00637"></a>00637   name = first_name;
<a name="l00638"></a>00638   va_start (arg_ptr, first_name);
<a name="l00639"></a>00639   <span class="keywordflow">do</span>
<a name="l00640"></a>00640     {
<a name="l00641"></a>00641       value = va_arg (arg_ptr, <span class="keyword">const</span> <span class="keywordtype">char</span> *);
<a name="l00642"></a>00642       <span class="keywordflow">if</span> (!value)
<a name="l00643"></a>00643         value = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00644"></a>00644       len = strlen (name);
<a name="l00645"></a>00645       <span class="keywordflow">if</span> (len)  <span class="comment">/* We skip pairs with an empty name. */</span>
<a name="l00646"></a>00646         {
<a name="l00647"></a>00647           put32 (stringbuf, len);
<a name="l00648"></a>00648           g_string_append (stringbuf, name);
<a name="l00649"></a>00649           len = strlen (value);
<a name="l00650"></a>00650           <span class="keywordflow">if</span> (len &gt; <a class="code" href="lsc__crypt_8c.html#a73728cb2adf706b78be4cd7ca7c27646" title="The maximum size of an encrypted value.">MAX_VALUE_LENGTH</a>)
<a name="l00651"></a>00651             {
<a name="l00652"></a>00652               g_warning (<span class="stringliteral">&quot;%s: value for &apos;%s&apos; larger than our limit (%d)&quot;</span>,
<a name="l00653"></a>00653                          G_STRFUNC, name, <a class="code" href="lsc__crypt_8c.html#a73728cb2adf706b78be4cd7ca7c27646" title="The maximum size of an encrypted value.">MAX_VALUE_LENGTH</a>);
<a name="l00654"></a>00654               g_string_free (stringbuf, TRUE);
<a name="l00655"></a>00655               va_end (arg_ptr);
<a name="l00656"></a>00656               <span class="keywordflow">return</span> NULL;
<a name="l00657"></a>00657             }
<a name="l00658"></a>00658           put32 (stringbuf, len);
<a name="l00659"></a>00659           g_string_append (stringbuf, value);
<a name="l00660"></a>00660         }
<a name="l00661"></a>00661     }
<a name="l00662"></a>00662   <span class="keywordflow">while</span> ((name = va_arg (arg_ptr, <span class="keyword">const</span> <span class="keywordtype">char</span> *)));
<a name="l00663"></a>00663   va_end (arg_ptr);
<a name="l00664"></a>00664   plaintext = stringbuf-&gt;str;
<a name="l00665"></a>00665   plaintextlen = stringbuf-&gt;len;
<a name="l00666"></a>00666   g_string_free (stringbuf, FALSE);
<a name="l00667"></a>00667   g_assert (plaintextlen);
<a name="l00668"></a>00668 
<a name="l00669"></a>00669   ciphertext = do_encrypt (ctx, plaintext, plaintextlen);
<a name="l00670"></a>00670   g_free (plaintext);
<a name="l00671"></a>00671 
<a name="l00672"></a>00672   <span class="keywordflow">return</span> ciphertext;
<a name="l00673"></a>00673 }
<a name="l00674"></a>00674 
<a name="l00675"></a>00675 
<a name="l00676"></a>00676 <span class="comment">/* Fixme: Shall we turn this into a public function? */</span>
<a name="l00677"></a>00677 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l00678"></a>00678 lsc_crypt_decrypt (<a class="code" href="structlsc__crypt__ctx__s.html" title="The context object for encryption operations.">lsc_crypt_ctx_t</a> ctx, <span class="keyword">const</span> <span class="keywordtype">char</span> *ciphertext,
<a name="l00679"></a>00679                    <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structnamelist__s.html#a10e5f9a9cf791f9201d3a41250b36c3a">name</a>)
<a name="l00680"></a>00680 {
<a name="l00681"></a>00681   <span class="keywordtype">size_t</span> namelen;
<a name="l00682"></a>00682   <span class="keyword">const</span> <span class="keywordtype">char</span> *p;
<a name="l00683"></a>00683   <span class="keywordtype">size_t</span> len;
<a name="l00684"></a>00684   uint32_t n;
<a name="l00685"></a>00685   <span class="keywordtype">int</span> found;
<a name="l00686"></a>00686   <span class="keyword">struct </span><a class="code" href="structnamelist__s.html" title="A linked list to help caching results.">namelist_s</a> *nl;
<a name="l00687"></a>00687 
<a name="l00688"></a>00688   <span class="keywordflow">if</span> (!ctx || !name || !*name)
<a name="l00689"></a>00689     <span class="keywordflow">return</span> NULL;
<a name="l00690"></a>00690   <span class="keywordflow">if</span> (<a class="code" href="lsc__crypt_8h.html#a273eb151f932f83e1f641f52e9c1b60c" title="Flag indicating that encrypted credentials are disabled.">disable_encrypted_credentials</a>)
<a name="l00691"></a>00691     {
<a name="l00692"></a>00692       <span class="keyword">static</span> gboolean shown;
<a name="l00693"></a>00693       <span class="keywordflow">if</span> (!shown)
<a name="l00694"></a>00694         {
<a name="l00695"></a>00695           shown = 1;
<a name="l00696"></a>00696           g_warning (<span class="stringliteral">&quot;note that decryption of credentials has been disabled&quot;</span>);
<a name="l00697"></a>00697         }
<a name="l00698"></a>00698       <span class="keywordflow">return</span> NULL;
<a name="l00699"></a>00699     }
<a name="l00700"></a>00700 
<a name="l00701"></a>00701   <span class="keywordflow">if</span> (!ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#abb5d2a695bfb86a8216151ef23d6fd07">plaintext</a>)
<a name="l00702"></a>00702     {
<a name="l00703"></a>00703       <span class="keywordflow">if</span> (!ciphertext)
<a name="l00704"></a>00704         <span class="keywordflow">return</span> NULL;
<a name="l00705"></a>00705       ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#abb5d2a695bfb86a8216151ef23d6fd07">plaintext</a> = do_decrypt (ctx, ciphertext, &amp;ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a66371ebe2ece8c38da509965be46f2e3">plaintextlen</a>);
<a name="l00706"></a>00706       <span class="keywordflow">if</span> (!ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#abb5d2a695bfb86a8216151ef23d6fd07">plaintext</a>)
<a name="l00707"></a>00707         <span class="keywordflow">return</span> NULL;
<a name="l00708"></a>00708     }
<a name="l00709"></a>00709 
<a name="l00710"></a>00710   <span class="comment">/* Try to return it from the cache.  */</span>
<a name="l00711"></a>00711   <span class="keywordflow">for</span> (nl = ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a29784e91a47ce697dde033756884b9e0">namelist</a>; nl; nl = nl-&gt;<a class="code" href="structnamelist__s.html#a1be5f6f2df8d3f70ded74bde5d94f5a1">next</a>)
<a name="l00712"></a>00712     <span class="keywordflow">if</span> (!strcmp (nl-&gt;<a class="code" href="structnamelist__s.html#a10e5f9a9cf791f9201d3a41250b36c3a">name</a>, name))
<a name="l00713"></a>00713       {
<a name="l00714"></a>00714         <span class="keywordflow">return</span> (nl-&gt;<a class="code" href="structnamelist__s.html#a2382546248b3fa55432d922fc5076f19">value</a>
<a name="l00715"></a>00715                 ? nl-&gt;<a class="code" href="structnamelist__s.html#a2382546248b3fa55432d922fc5076f19">value</a>
<a name="l00716"></a>00716                 : (nl-&gt;<a class="code" href="structnamelist__s.html#a5b4c973693b91f7e2077e47382addc30">valoff</a> ? (ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#abb5d2a695bfb86a8216151ef23d6fd07">plaintext</a> + nl-&gt;<a class="code" href="structnamelist__s.html#a5b4c973693b91f7e2077e47382addc30">valoff</a>) : NULL));
<a name="l00717"></a>00717       }
<a name="l00718"></a>00718 
<a name="l00719"></a>00719   <span class="comment">/* Cache miss: Parse the data, cache the result, and return it.  */</span>
<a name="l00720"></a>00720   <span class="comment">/* Fixme: Cache a not found status.  */</span>
<a name="l00721"></a>00721   namelen = strlen (name);
<a name="l00722"></a>00722   p   = ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#abb5d2a695bfb86a8216151ef23d6fd07">plaintext</a>;
<a name="l00723"></a>00723   len = ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a66371ebe2ece8c38da509965be46f2e3">plaintextlen</a>;
<a name="l00724"></a>00724   found = 0;
<a name="l00725"></a>00725   <span class="keywordflow">while</span> (len)
<a name="l00726"></a>00726     {
<a name="l00727"></a>00727       <span class="keywordflow">if</span> (len &lt; 4)
<a name="l00728"></a>00728         <span class="keywordflow">goto</span> failed;
<a name="l00729"></a>00729       n = get32 (p); p += 4; len -= 4;
<a name="l00730"></a>00730       <span class="keywordflow">if</span> (n &gt; len)
<a name="l00731"></a>00731         <span class="keywordflow">goto</span> failed;
<a name="l00732"></a>00732       <span class="keywordflow">if</span> (n == namelen &amp;&amp; !memcmp (p, name, namelen))
<a name="l00733"></a>00733         found = 1;
<a name="l00734"></a>00734       p += n; len -= n;
<a name="l00735"></a>00735       <span class="keywordflow">if</span> (len &lt; 4)
<a name="l00736"></a>00736         <span class="keywordflow">goto</span> failed;
<a name="l00737"></a>00737       n = get32 (p); p += 4; len -= 4;
<a name="l00738"></a>00738       <span class="keywordflow">if</span> (n &gt; len)
<a name="l00739"></a>00739         <span class="keywordflow">goto</span> failed;
<a name="l00740"></a>00740       <span class="keywordflow">if</span> (found)
<a name="l00741"></a>00741         {
<a name="l00742"></a>00742           <span class="keywordflow">if</span> (n &gt; <a class="code" href="lsc__crypt_8c.html#a73728cb2adf706b78be4cd7ca7c27646" title="The maximum size of an encrypted value.">MAX_VALUE_LENGTH</a>)
<a name="l00743"></a>00743             {
<a name="l00744"></a>00744               g_warning (<span class="stringliteral">&quot;%s: value for &apos;%s&apos; larger than our limit (%d)&quot;</span>,
<a name="l00745"></a>00745                          G_STRFUNC, name, <a class="code" href="lsc__crypt_8c.html#a73728cb2adf706b78be4cd7ca7c27646" title="The maximum size of an encrypted value.">MAX_VALUE_LENGTH</a>);
<a name="l00746"></a>00746               <span class="keywordflow">return</span> NULL;
<a name="l00747"></a>00747             }
<a name="l00748"></a>00748           nl = g_malloc (<span class="keyword">sizeof</span> *nl + namelen);
<a name="l00749"></a>00749           strcpy (nl-&gt;<a class="code" href="structnamelist__s.html#a10e5f9a9cf791f9201d3a41250b36c3a">name</a>, name);
<a name="l00750"></a>00750           <span class="keywordflow">if</span> (n + 1 &lt; len &amp;&amp; p[n] == 0)
<a name="l00751"></a>00751             {
<a name="l00752"></a>00752               <span class="comment">/* The values is followed by another name and the first</span>
<a name="l00753"></a>00753 <span class="comment">                 byte of that name&apos;s length is 0.  Thus we don&apos;t need</span>
<a name="l00754"></a>00754 <span class="comment">                 to take a copy because that length byte acts as the</span>
<a name="l00755"></a>00755 <span class="comment">                 string terminator.  */</span>
<a name="l00756"></a>00756               nl-&gt;<a class="code" href="structnamelist__s.html#a5b4c973693b91f7e2077e47382addc30">valoff</a> = (p - ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#abb5d2a695bfb86a8216151ef23d6fd07">plaintext</a>);
<a name="l00757"></a>00757               nl-&gt;<a class="code" href="structnamelist__s.html#a2382546248b3fa55432d922fc5076f19">value</a>  = NULL;
<a name="l00758"></a>00758             }
<a name="l00759"></a>00759           <span class="keywordflow">else</span>
<a name="l00760"></a>00760             {
<a name="l00761"></a>00761               <span class="comment">/* We need to take a copy of the value, so that we can</span>
<a name="l00762"></a>00762 <span class="comment">                 add the string terminator.  */</span>
<a name="l00763"></a>00763               nl-&gt;<a class="code" href="structnamelist__s.html#a5b4c973693b91f7e2077e47382addc30">valoff</a> = 0;
<a name="l00764"></a>00764               nl-&gt;<a class="code" href="structnamelist__s.html#a2382546248b3fa55432d922fc5076f19">value</a> = g_malloc (n + 1);
<a name="l00765"></a>00765               memcpy (nl-&gt;<a class="code" href="structnamelist__s.html#a2382546248b3fa55432d922fc5076f19">value</a>, p, n);
<a name="l00766"></a>00766               nl-&gt;<a class="code" href="structnamelist__s.html#a2382546248b3fa55432d922fc5076f19">value</a>[n] = 0;
<a name="l00767"></a>00767             }
<a name="l00768"></a>00768           nl-&gt;<a class="code" href="structnamelist__s.html#a1be5f6f2df8d3f70ded74bde5d94f5a1">next</a> = ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a29784e91a47ce697dde033756884b9e0">namelist</a>;
<a name="l00769"></a>00769           ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a29784e91a47ce697dde033756884b9e0">namelist</a> = nl;
<a name="l00770"></a>00770           <span class="keywordflow">return</span> nl-&gt;<a class="code" href="structnamelist__s.html#a2382546248b3fa55432d922fc5076f19">value</a>? nl-&gt;<a class="code" href="structnamelist__s.html#a2382546248b3fa55432d922fc5076f19">value</a> : (ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#abb5d2a695bfb86a8216151ef23d6fd07">plaintext</a> + nl-&gt;<a class="code" href="structnamelist__s.html#a5b4c973693b91f7e2077e47382addc30">valoff</a>);
<a name="l00771"></a>00771         }
<a name="l00772"></a>00772       p += n; len -= n;
<a name="l00773"></a>00773     }
<a name="l00774"></a>00774   <span class="keywordflow">if</span> (!len)
<a name="l00775"></a>00775     <span class="keywordflow">goto</span> not_found;
<a name="l00776"></a>00776 
<a name="l00777"></a>00777  failed:
<a name="l00778"></a>00778   g_warning (<span class="stringliteral">&quot;%s: decrypted credential data block is inconsistent;&quot;</span>
<a name="l00779"></a>00779              <span class="stringliteral">&quot; %zu bytes remaining at offset %zu&quot;</span>,
<a name="l00780"></a>00780              G_STRFUNC, len, (<span class="keywordtype">size_t</span>)(p - ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#abb5d2a695bfb86a8216151ef23d6fd07">plaintext</a>));
<a name="l00781"></a>00781  not_found:
<a name="l00782"></a>00782   <span class="comment">/* Cache a NULL value.  */</span>
<a name="l00783"></a>00783   nl = g_malloc (<span class="keyword">sizeof</span> *nl + namelen);
<a name="l00784"></a>00784   strcpy (nl-&gt;<a class="code" href="structnamelist__s.html#a10e5f9a9cf791f9201d3a41250b36c3a">name</a>, name);
<a name="l00785"></a>00785   nl-&gt;<a class="code" href="structnamelist__s.html#a5b4c973693b91f7e2077e47382addc30">valoff</a> = 0;
<a name="l00786"></a>00786   nl-&gt;<a class="code" href="structnamelist__s.html#a2382546248b3fa55432d922fc5076f19">value</a>  = NULL;
<a name="l00787"></a>00787   nl-&gt;<a class="code" href="structnamelist__s.html#a1be5f6f2df8d3f70ded74bde5d94f5a1">next</a> = ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a29784e91a47ce697dde033756884b9e0">namelist</a>;
<a name="l00788"></a>00788   ctx-&gt;<a class="code" href="structlsc__crypt__ctx__s.html#a29784e91a47ce697dde033756884b9e0">namelist</a> = nl;
<a name="l00789"></a>00789   <span class="keywordflow">return</span> NULL;
<a name="l00790"></a>00790 }
<a name="l00791"></a>00791 
<a name="l00792"></a>00792 
<a name="l00811"></a>00811 <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l00812"></a><a class="code" href="lsc__crypt_8h.html#ab6fce07a5d0e066f2a4361840b72b176">00812</a> <a class="code" href="lsc__crypt_8c.html#aceb512c855914950547548b3a3c5af0b" title="Return an encrypted password in the clear.">lsc_crypt_get_password</a> (<a class="code" href="structlsc__crypt__ctx__s.html" title="The context object for encryption operations.">lsc_crypt_ctx_t</a> ctx, <span class="keyword">const</span> <span class="keywordtype">char</span> *ciphertext)
<a name="l00813"></a>00813 {
<a name="l00814"></a>00814   <span class="keywordflow">return</span> lsc_crypt_decrypt (ctx, ciphertext, <span class="stringliteral">&quot;password&quot;</span>);
<a name="l00815"></a>00815 }
<a name="l00816"></a>00816 
<a name="l00817"></a>00817 
<a name="l00818"></a>00818 <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l00819"></a><a class="code" href="lsc__crypt_8h.html#a96fa8a8d533f12bb2c4e6328f6e19184">00819</a> <a class="code" href="lsc__crypt_8c.html#aab3b8de6e56f35fe62c50c933b0f4e68">lsc_crypt_get_private_key</a> (<a class="code" href="structlsc__crypt__ctx__s.html" title="The context object for encryption operations.">lsc_crypt_ctx_t</a> ctx, <span class="keyword">const</span> <span class="keywordtype">char</span> *ciphertext)
<a name="l00820"></a>00820 {
<a name="l00821"></a>00821   <span class="keywordflow">return</span> lsc_crypt_decrypt (ctx, ciphertext, <span class="stringliteral">&quot;private_key&quot;</span>);
<a name="l00822"></a>00822 }
</pre></div></div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 23 Oct 2015 for OpenVAS Manager by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
