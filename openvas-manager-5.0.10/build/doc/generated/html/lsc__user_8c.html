<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>OpenVAS Manager: src/lsc_user.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_2e42f16cd70e299165562ff45749e93d.html">src</a>
  </div>
</div>
<div class="contents">
<h1>lsc_user.c File Reference</h1><code>#include &lt;glib.h&gt;</code><br/>
<code>#include &lt;glib/gstdio.h&gt;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;unistd.h&gt;</code><br/>
<code>#include &lt;sys/stat.h&gt;</code><br/>
<code>#include &lt;sys/types.h&gt;</code><br/>
<code>#include &lt;sys/wait.h&gt;</code><br/>
<code>#include &lt;openvas/base/openvas_file.h&gt;</code><br/>
<div class="dynheader">
Include dependency graph for lsc_user.c:</div>
<div class="dynsection">
</div>

<p><a href="lsc__user_8c_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lsc__user_8c.html#a1810a09af583816ca6b4ccf01ae848f7">G_LOG_DOMAIN</a>&nbsp;&nbsp;&nbsp;&quot;md manage&quot;</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GLib log domain.  <a href="#a1810a09af583816ca6b4ccf01ae848f7"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lsc__user_8c.html#adcce73c5fced7985c6d2237fd80cbe2d">lsc_user_keys_create</a> (const gchar *password, gchar **public_key, gchar **private_key)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create local security check (LSC) keys.  <a href="#adcce73c5fced7985c6d2237fd80cbe2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lsc__user_8c.html#aa64e405a7ada1d95fc6175fc2e87d3a9">lsc_user_rpm_recreate</a> (const gchar *name, const char *public_key, void **rpm, gsize *rpm_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">gchar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lsc__user_8c.html#a993f21060929b22c21d291aa109f290c">lsc_user_deb_create</a> (const gchar *user, const gchar *rpm_file)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a Debian package from an LSC user RPM package.  <a href="#a993f21060929b22c21d291aa109f290c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lsc__user_8c.html#ad28379fa7f163791252cffe94b23846b">lsc_user_deb_recreate</a> (const gchar *name, const char *rpm, gsize rpm_size, void **deb, gsize *deb_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="lsc__user_8c.html#ac24fa9cd85945c4c541a98ac644ea1b5">lsc_user_exe_recreate</a> (const gchar *name, const gchar *password, void **exe, gsize *exe_size)</td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a1810a09af583816ca6b4ccf01ae848f7"></a><!-- doxytag: member="lsc_user.c::G_LOG_DOMAIN" ref="a1810a09af583816ca6b4ccf01ae848f7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define G_LOG_DOMAIN&nbsp;&nbsp;&nbsp;&quot;md manage&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>GLib log domain. </p>

<p>Definition at line <a class="el" href="lsc__user_8c_source.html#l00048">48</a> of file <a class="el" href="lsc__user_8c_source.html">lsc_user.c</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a993f21060929b22c21d291aa109f290c"></a><!-- doxytag: member="lsc_user.c::lsc_user_deb_create" ref="a993f21060929b22c21d291aa109f290c" args="(const gchar *user, const gchar *rpm_file)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gchar* lsc_user_deb_create </td>
          <td>(</td>
          <td class="paramtype">const gchar *&nbsp;</td>
          <td class="paramname"> <em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gchar *&nbsp;</td>
          <td class="paramname"> <em>rpm_file</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a Debian package from an LSC user RPM package. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>user</em>&nbsp;</td><td>Name of user. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rpm_file</em>&nbsp;</td><td>Location of the RPM file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Debian package file name on success, else NULL. </dd></dl>

<p>Definition at line <a class="el" href="lsc__user_8c_source.html#l00575">575</a> of file <a class="el" href="lsc__user_8c_source.html">lsc_user.c</a>.</p>

<p>Referenced by <a class="el" href="lsc__user_8c_source.html#l00613">lsc_user_deb_recreate()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00576"></a>00576 {
<a name="l00577"></a>00577   gchar *dirname = g_path_get_dirname (rpm_file);
<a name="l00578"></a>00578   gchar *dir = g_strconcat (dirname, <span class="stringliteral">&quot;/&quot;</span>, NULL);
<a name="l00579"></a>00579   gchar *basename = g_path_get_basename (rpm_file);
<a name="l00580"></a>00580   gchar *down_user = g_ascii_strdown (user ? user : <span class="stringliteral">&quot;user&quot;</span>, -1);
<a name="l00581"></a>00581   gchar *deb_name = g_strdup_printf (<span class="stringliteral">&quot;%s/openvas-lsc-target-%s_0.5-1_all.deb&quot;</span>,
<a name="l00582"></a>00582                                      dirname, down_user);
<a name="l00583"></a>00583 
<a name="l00584"></a>00584   g_free (dirname);
<a name="l00585"></a>00585   g_free (down_user);
<a name="l00586"></a>00586 
<a name="l00587"></a>00587   <span class="keywordflow">if</span> (execute_alien (dir, basename))
<a name="l00588"></a>00588     {
<a name="l00589"></a>00589       g_free (dir);
<a name="l00590"></a>00590       g_free (basename);
<a name="l00591"></a>00591       g_free (deb_name);
<a name="l00592"></a>00592       <span class="keywordflow">return</span> NULL;
<a name="l00593"></a>00593     }
<a name="l00594"></a>00594 
<a name="l00595"></a>00595   g_free (dir);
<a name="l00596"></a>00596   g_free (basename);
<a name="l00597"></a>00597 
<a name="l00598"></a>00598   <span class="keywordflow">return</span> deb_name;
<a name="l00599"></a>00599 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="ad28379fa7f163791252cffe94b23846b"></a><!-- doxytag: member="lsc_user.c::lsc_user_deb_recreate" ref="ad28379fa7f163791252cffe94b23846b" args="(const gchar *name, const char *rpm, gsize rpm_size, void **deb, gsize *deb_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lsc_user_deb_recreate </td>
          <td>(</td>
          <td class="paramtype">const gchar *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>rpm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&nbsp;</td>
          <td class="paramname"> <em>rpm_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>deb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize *&nbsp;</td>
          <td class="paramname"> <em>deb_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lsc__user_8c_source.html#l00613">613</a> of file <a class="el" href="lsc__user_8c_source.html">lsc_user.c</a>.</p>

<p>References <a class="el" href="lsc__user_8c_source.html#l00575">lsc_user_deb_create()</a>.</p>

<p>Referenced by <a class="el" href="manage__sql_8c_source.html#l34121">lsc_credential_iterator_deb()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00615"></a>00615 {
<a name="l00616"></a>00616   GError *error;
<a name="l00617"></a>00617   <span class="keywordtype">char</span> deb_dir[] = <span class="stringliteral">&quot;/tmp/deb_XXXXXX&quot;</span>;
<a name="l00618"></a>00618   <span class="keywordtype">char</span> rpm_dir[] = <span class="stringliteral">&quot;/tmp/rpm_XXXXXX&quot;</span>;
<a name="l00619"></a>00619   gchar *deb_path, *rpm_path;
<a name="l00620"></a>00620   <span class="keywordtype">int</span> ret = -1;
<a name="l00621"></a>00621 
<a name="l00622"></a>00622   <span class="keywordflow">if</span> (alien_found () == FALSE)
<a name="l00623"></a>00623     <span class="keywordflow">return</span> -1;
<a name="l00624"></a>00624 
<a name="l00625"></a>00625   <span class="comment">/* Make a directory for the RPM. */</span>
<a name="l00626"></a>00626 
<a name="l00627"></a>00627   <span class="keywordflow">if</span> (mkdtemp (rpm_dir) == NULL)
<a name="l00628"></a>00628     <span class="keywordflow">return</span> -1;
<a name="l00629"></a>00629 
<a name="l00630"></a>00630   <span class="comment">/* Write RPM to disk. */</span>
<a name="l00631"></a>00631 
<a name="l00632"></a>00632   error = NULL;
<a name="l00633"></a>00633   rpm_path = g_build_filename (rpm_dir, <span class="stringliteral">&quot;p.rpm&quot;</span>, NULL);
<a name="l00634"></a>00634   g_file_set_contents (rpm_path, rpm, rpm_size, &amp;error);
<a name="l00635"></a>00635   <span class="keywordflow">if</span> (error)
<a name="l00636"></a>00636     <span class="keywordflow">goto</span> free_exit;
<a name="l00637"></a>00637 
<a name="l00638"></a>00638   <span class="comment">/* Create Debian package. */</span>
<a name="l00639"></a>00639 
<a name="l00640"></a>00640   <span class="keywordflow">if</span> (mkdtemp (deb_dir) == NULL)
<a name="l00641"></a>00641     <span class="keywordflow">goto</span> free_exit;
<a name="l00642"></a>00642   deb_path = <a class="code" href="lsc__user_8c.html#a993f21060929b22c21d291aa109f290c" title="Create a Debian package from an LSC user RPM package.">lsc_user_deb_create</a> (<a class="code" href="structnamelist__s.html#a10e5f9a9cf791f9201d3a41250b36c3a">name</a>, rpm_path);
<a name="l00643"></a>00643   <span class="keywordflow">if</span> (deb_path == NULL)
<a name="l00644"></a>00644     <span class="keywordflow">goto</span> rm_exit;
<a name="l00645"></a>00645 
<a name="l00646"></a>00646   <span class="comment">/* Read the package into memory. */</span>
<a name="l00647"></a>00647 
<a name="l00648"></a>00648   error = NULL;
<a name="l00649"></a>00649   g_file_get_contents (deb_path, (gchar **) deb, deb_size, &amp;error);
<a name="l00650"></a>00650   g_free (deb_path);
<a name="l00651"></a>00651   <span class="keywordflow">if</span> (error)
<a name="l00652"></a>00652     {
<a name="l00653"></a>00653       g_error_free (error);
<a name="l00654"></a>00654       <span class="keywordflow">goto</span> rm_exit;
<a name="l00655"></a>00655     }
<a name="l00656"></a>00656 
<a name="l00657"></a>00657   <span class="comment">/* Return. */</span>
<a name="l00658"></a>00658 
<a name="l00659"></a>00659   ret = 0;
<a name="l00660"></a>00660 
<a name="l00661"></a>00661  rm_exit:
<a name="l00662"></a>00662 
<a name="l00663"></a>00663   openvas_file_remove_recurse (deb_dir);
<a name="l00664"></a>00664 
<a name="l00665"></a>00665  free_exit:
<a name="l00666"></a>00666 
<a name="l00667"></a>00667   g_free (rpm_path);
<a name="l00668"></a>00668 
<a name="l00669"></a>00669   openvas_file_remove_recurse (rpm_dir);
<a name="l00670"></a>00670 
<a name="l00671"></a>00671   <span class="keywordflow">return</span> ret;
<a name="l00672"></a>00672 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="ac24fa9cd85945c4c541a98ac644ea1b5"></a><!-- doxytag: member="lsc_user.c::lsc_user_exe_recreate" ref="ac24fa9cd85945c4c541a98ac644ea1b5" args="(const gchar *name, const gchar *password, void **exe, gsize *exe_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lsc_user_exe_recreate </td>
          <td>(</td>
          <td class="paramtype">const gchar *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gchar *&nbsp;</td>
          <td class="paramname"> <em>password</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>exe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize *&nbsp;</td>
          <td class="paramname"> <em>exe_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lsc__user_8c_source.html#l00889">889</a> of file <a class="el" href="lsc__user_8c_source.html">lsc_user.c</a>.</p>

<p>Referenced by <a class="el" href="manage__sql_8c_source.html#l34157">lsc_credential_iterator_exe()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00891"></a>00891 {
<a name="l00892"></a>00892   GError *error;
<a name="l00893"></a>00893   <span class="keywordtype">char</span> exe_dir[] = <span class="stringliteral">&quot;/tmp/exe_XXXXXX&quot;</span>;
<a name="l00894"></a>00894   gchar *exe_path;
<a name="l00895"></a>00895   <span class="keywordtype">int</span> ret = -1;
<a name="l00896"></a>00896 
<a name="l00897"></a>00897   <span class="keywordflow">if</span> (alien_found () == FALSE)
<a name="l00898"></a>00898     <span class="keywordflow">return</span> -1;
<a name="l00899"></a>00899 
<a name="l00900"></a>00900   <span class="comment">/* Create NSIS package. */</span>
<a name="l00901"></a>00901 
<a name="l00902"></a>00902   <span class="keywordflow">if</span> (mkdtemp (exe_dir) == NULL)
<a name="l00903"></a>00903     <span class="keywordflow">return</span> -1;
<a name="l00904"></a>00904   exe_path = g_build_filename (exe_dir, <span class="stringliteral">&quot;p.nsis&quot;</span>, NULL);
<a name="l00905"></a>00905   <span class="keywordflow">if</span> (lsc_user_exe_create (<a class="code" href="structnamelist__s.html#a10e5f9a9cf791f9201d3a41250b36c3a">name</a>, password, exe_path))
<a name="l00906"></a>00906     <span class="keywordflow">goto</span> rm_exit;
<a name="l00907"></a>00907 
<a name="l00908"></a>00908   <span class="comment">/* Read the package into memory. */</span>
<a name="l00909"></a>00909 
<a name="l00910"></a>00910   error = NULL;
<a name="l00911"></a>00911   g_file_get_contents (exe_path, (gchar **) exe, exe_size, &amp;error);
<a name="l00912"></a>00912   <span class="keywordflow">if</span> (error)
<a name="l00913"></a>00913     {
<a name="l00914"></a>00914       g_error_free (error);
<a name="l00915"></a>00915       <span class="keywordflow">goto</span> rm_exit;
<a name="l00916"></a>00916     }
<a name="l00917"></a>00917 
<a name="l00918"></a>00918   <span class="comment">/* Return. */</span>
<a name="l00919"></a>00919 
<a name="l00920"></a>00920   ret = 0;
<a name="l00921"></a>00921 
<a name="l00922"></a>00922  rm_exit:
<a name="l00923"></a>00923 
<a name="l00924"></a>00924   openvas_file_remove_recurse (exe_dir);
<a name="l00925"></a>00925 
<a name="l00926"></a>00926   g_free (exe_path);
<a name="l00927"></a>00927 
<a name="l00928"></a>00928   <span class="keywordflow">return</span> ret;
<a name="l00929"></a>00929 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="adcce73c5fced7985c6d2237fd80cbe2d"></a><!-- doxytag: member="lsc_user.c::lsc_user_keys_create" ref="adcce73c5fced7985c6d2237fd80cbe2d" args="(const gchar *password, gchar **public_key, gchar **private_key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lsc_user_keys_create </td>
          <td>(</td>
          <td class="paramtype">const gchar *&nbsp;</td>
          <td class="paramname"> <em>password</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gchar **&nbsp;</td>
          <td class="paramname"> <em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gchar **&nbsp;</td>
          <td class="paramname"> <em>private_key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create local security check (LSC) keys. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>password</em>&nbsp;</td><td>Password. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>public_key</em>&nbsp;</td><td>Public key. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>private_key</em>&nbsp;</td><td>Private key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 success, -1 error. </dd></dl>

<p>Definition at line <a class="el" href="lsc__user_8c_source.html#l00182">182</a> of file <a class="el" href="lsc__user_8c_source.html">lsc_user.c</a>.</p>

<p>Referenced by <a class="el" href="manage__sql_8c_source.html#l33148">create_lsc_credential()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00185"></a>00185 {
<a name="l00186"></a>00186   GError *error;
<a name="l00187"></a>00187   gsize length;
<a name="l00188"></a>00188   <span class="keywordtype">char</span> key_dir[] = <span class="stringliteral">&quot;/tmp/openvas_key_XXXXXX&quot;</span>;
<a name="l00189"></a>00189   gchar *key_path = NULL, pub_path[2048];
<a name="l00190"></a>00190   <span class="keywordtype">int</span> ret = -1;
<a name="l00191"></a>00191 
<a name="l00192"></a>00192   <span class="comment">/* Make a directory for the keys. */</span>
<a name="l00193"></a>00193 
<a name="l00194"></a>00194   <span class="keywordflow">if</span> (mkdtemp (key_dir) == NULL)
<a name="l00195"></a>00195     <span class="keywordflow">return</span> -1;
<a name="l00196"></a>00196 
<a name="l00197"></a>00197   <span class="comment">/* Create private key. */</span>
<a name="l00198"></a>00198   key_path = g_build_filename (key_dir, <span class="stringliteral">&quot;key&quot;</span>, NULL);
<a name="l00199"></a>00199   <span class="keywordflow">if</span> (create_ssh_key (<span class="stringliteral">&quot;Key generated by OpenVAS Manager&quot;</span>, password, key_path))
<a name="l00200"></a>00200     <span class="keywordflow">goto</span> free_exit;
<a name="l00201"></a>00201 
<a name="l00202"></a>00202   error = NULL;
<a name="l00203"></a>00203   g_file_get_contents (key_path, private_key, &amp;length, &amp;error);
<a name="l00204"></a>00204   <span class="keywordflow">if</span> (error)
<a name="l00205"></a>00205     {
<a name="l00206"></a>00206       g_error_free (error);
<a name="l00207"></a>00207       <span class="keywordflow">goto</span> free_exit;
<a name="l00208"></a>00208     }
<a name="l00209"></a>00209 
<a name="l00210"></a>00210   snprintf (pub_path, <span class="keyword">sizeof</span> (pub_path), <span class="stringliteral">&quot;%s.pub&quot;</span>, key_path);
<a name="l00211"></a>00211   g_file_get_contents (pub_path, public_key, &amp;length, &amp;error);
<a name="l00212"></a>00212   <span class="keywordflow">if</span> (error)
<a name="l00213"></a>00213     {
<a name="l00214"></a>00214       g_error_free (error);
<a name="l00215"></a>00215       <span class="keywordflow">goto</span> free_exit;
<a name="l00216"></a>00216     }
<a name="l00217"></a>00217   ret = 0;
<a name="l00218"></a>00218  free_exit:
<a name="l00219"></a>00219 
<a name="l00220"></a>00220   g_free (key_path);
<a name="l00221"></a>00221   openvas_file_remove_recurse (key_dir);
<a name="l00222"></a>00222   <span class="keywordflow">return</span> ret;
<a name="l00223"></a>00223 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="aa64e405a7ada1d95fc6175fc2e87d3a9"></a><!-- doxytag: member="lsc_user.c::lsc_user_rpm_recreate" ref="aa64e405a7ada1d95fc6175fc2e87d3a9" args="(const gchar *name, const char *public_key, void **rpm, gsize *rpm_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lsc_user_rpm_recreate </td>
          <td>(</td>
          <td class="paramtype">const gchar *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>public_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>rpm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize *&nbsp;</td>
          <td class="paramname"> <em>rpm_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="lsc__user_8c_source.html#l00430">430</a> of file <a class="el" href="lsc__user_8c_source.html">lsc_user.c</a>.</p>

<p>Referenced by <a class="el" href="manage__sql_8c_source.html#l34121">lsc_credential_iterator_deb()</a>, and <a class="el" href="manage__sql_8c_source.html#l34092">lsc_credential_iterator_rpm()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00432"></a>00432 {
<a name="l00433"></a>00433   GError *error;
<a name="l00434"></a>00434   <span class="keywordtype">char</span> rpm_dir[] = <span class="stringliteral">&quot;/tmp/rpm_XXXXXX&quot;</span>;
<a name="l00435"></a>00435   <span class="keywordtype">char</span> key_dir[] = <span class="stringliteral">&quot;/tmp/key_XXXXXX&quot;</span>;
<a name="l00436"></a>00436   gchar *rpm_path, *public_key_path;
<a name="l00437"></a>00437   <span class="keywordtype">int</span> ret = -1;
<a name="l00438"></a>00438 
<a name="l00439"></a>00439   <span class="keywordflow">if</span> (alien_found () == FALSE)
<a name="l00440"></a>00440     <span class="keywordflow">return</span> -1;
<a name="l00441"></a>00441 
<a name="l00442"></a>00442   <span class="comment">/* Make a directory for the key. */</span>
<a name="l00443"></a>00443 
<a name="l00444"></a>00444   <span class="keywordflow">if</span> (mkdtemp (key_dir) == NULL)
<a name="l00445"></a>00445     <span class="keywordflow">return</span> -1;
<a name="l00446"></a>00446 
<a name="l00447"></a>00447   <span class="comment">/* Write public key to file. */</span>
<a name="l00448"></a>00448 
<a name="l00449"></a>00449   error = NULL;
<a name="l00450"></a>00450   public_key_path = g_build_filename (key_dir, <span class="stringliteral">&quot;key.pub&quot;</span>, NULL);
<a name="l00451"></a>00451   g_file_set_contents (public_key_path, public_key, strlen (public_key),
<a name="l00452"></a>00452                        &amp;error);
<a name="l00453"></a>00453   <span class="keywordflow">if</span> (error)
<a name="l00454"></a>00454     <span class="keywordflow">goto</span> free_exit;
<a name="l00455"></a>00455 
<a name="l00456"></a>00456   <span class="comment">/* Create RPM package. */</span>
<a name="l00457"></a>00457 
<a name="l00458"></a>00458   <span class="keywordflow">if</span> (mkdtemp (rpm_dir) == NULL)
<a name="l00459"></a>00459     <span class="keywordflow">goto</span> free_exit;
<a name="l00460"></a>00460   rpm_path = g_build_filename (rpm_dir, <span class="stringliteral">&quot;p.rpm&quot;</span>, NULL);
<a name="l00461"></a>00461   g_debug (<span class="stringliteral">&quot;%s: rpm_path: %s&quot;</span>, __FUNCTION__, rpm_path);
<a name="l00462"></a>00462   <span class="keywordflow">if</span> (lsc_user_rpm_create (<a class="code" href="structnamelist__s.html#a10e5f9a9cf791f9201d3a41250b36c3a">name</a>, public_key_path, rpm_path) == FALSE)
<a name="l00463"></a>00463     {
<a name="l00464"></a>00464       g_free (rpm_path);
<a name="l00465"></a>00465       <span class="keywordflow">goto</span> rm_exit;
<a name="l00466"></a>00466     }
<a name="l00467"></a>00467 
<a name="l00468"></a>00468   <span class="comment">/* Read the package into memory. */</span>
<a name="l00469"></a>00469 
<a name="l00470"></a>00470   error = NULL;
<a name="l00471"></a>00471   g_file_get_contents (rpm_path, (gchar **) rpm, rpm_size, &amp;error);
<a name="l00472"></a>00472   g_free (rpm_path);
<a name="l00473"></a>00473   <span class="keywordflow">if</span> (error)
<a name="l00474"></a>00474     {
<a name="l00475"></a>00475       g_error_free (error);
<a name="l00476"></a>00476       <span class="keywordflow">goto</span> rm_exit;
<a name="l00477"></a>00477     }
<a name="l00478"></a>00478 
<a name="l00479"></a>00479   <span class="comment">/* Return. */</span>
<a name="l00480"></a>00480 
<a name="l00481"></a>00481   ret = 0;
<a name="l00482"></a>00482 
<a name="l00483"></a>00483  rm_exit:
<a name="l00484"></a>00484 
<a name="l00485"></a>00485   openvas_file_remove_recurse (rpm_dir);
<a name="l00486"></a>00486 
<a name="l00487"></a>00487  free_exit:
<a name="l00488"></a>00488 
<a name="l00489"></a>00489   g_free (public_key_path);
<a name="l00490"></a>00490 
<a name="l00491"></a>00491   openvas_file_remove_recurse (key_dir);
<a name="l00492"></a>00492 
<a name="l00493"></a>00493   <span class="keywordflow">return</span> ret;
<a name="l00494"></a>00494 }
</pre></div></p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on 23 Oct 2015 for OpenVAS Manager by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
